use actix_web::{get, web::Query, App, HttpResponse, HttpServer};
use async_trait::async_trait;
use serde_derive::{Deserialize, Serialize};
use shaku::{module, Component, Interface};
use shaku_actix::Inject;
use std::{collections::HashMap, sync::Arc};

#[derive(Debug, Clone, Serialize)]
struct Bank {
    name: String,
}

#[async_trait]
trait BankFinder: Interface {
    async fn find(&self, name: String) -> Option<Bank>;
}

#[derive(Component)]
#[shaku(interface = BankFinder)]
struct BankFinderimpl {
    #[shaku(inject)]
    bank_repository: Arc<dyn BankRepository>,
}

#[async_trait]
impl BankFinder for BankFinderimpl {
    async fn find(&self, name: String) -> Option<Bank> {
        self.bank_repository.find(name)
    }
}

// #[async_trait]
// trait BankRegister: Interface {
//     async fn register(&mut self, name: String);
// }

// #[derive(Component)]
// #[shaku(interface = BankRegister)]
// struct BankRegisterImpl {
//     #[shaku(inject)]
//     bank_repository: Arc<Mutex<dyn BankRepository>>,
// }

// #[async_trait]
// impl BankRegister for BankRegisterImpl {
//     async fn register(&mut self, name: String) {
//         let mut lock = self.bank_repository.lock().unwrap();
//         lock.insert(Bank { name });
//     }
// }

trait BankRepository: Interface {
    fn find(&self, name: String) -> Option<Bank>;
    fn insert(&mut self, bank: Bank);
}

// TODO I think the implementation should be replaced with an example by connecting to databases.
#[derive(Component)]
#[shaku(interface = BankRepository)]
struct BankRepositoryOnMemory {
    db: HashMap<String, Bank>,
}

impl BankRepository for BankRepositoryOnMemory {
    fn find(&self, name: String) -> Option<Bank> {
        self.db.get(&name).cloned()
    }

    fn insert(&mut self, bank: Bank) {
        self.db.insert(bank.name.clone(), bank);
    }
}

module! {
    AppModule {
        components = [BankFinderimpl, BankRepositoryOnMemory],
        providers = []
    }
}

#[derive(Deserialize)]
struct SearchQuery {
    name: String,
}

#[derive(Serialize)]
struct BankSearchResponse(Option<Bank>);

#[get("/banks")]
async fn search_bank(
    query: Query<SearchQuery>,
    finder: Inject<AppModule, dyn BankFinder>,
) -> HttpResponse {
    let query = query.into_inner();
    let bank = finder.find(query.name).await;
    HttpResponse::Ok().json(BankSearchResponse(bank))
}

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    // BankRepositoryOnMemoryParameters will be auto-generated by macro.
    let module = Arc::new(
        AppModule::builder()
            .with_component_parameters::<BankRepositoryOnMemory>(BankRepositoryOnMemoryParameters {
                db: HashMap::new(),
            })
            // with_component_parameters function can be repeatedly used.
            .build(),
    );
    HttpServer::new(move || App::new().service(search_bank).app_data(module.clone()))
        .bind(("127.0.0.1", 8080))?
        .run()
        .await
}
