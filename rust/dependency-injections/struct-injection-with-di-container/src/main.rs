use std::{
    collections::HashMap,
    sync::{Arc, Mutex},
};

use async_trait::async_trait;
use shaku::{module, Component, HasComponent, Interface};

#[derive(Debug, Clone)]
struct Bank {
    name: String,
}

#[async_trait]
trait BankFinder: Interface {
    async fn find(&self, name: String) -> Option<Bank>;
}

#[derive(Component)]
#[shaku(interface = BankFinder)]
struct BankFinderimpl {
    bank_repository: Arc<dyn BankRepository>,
}

#[async_trait]
impl BankFinder for BankFinderimpl {
    async fn find(&self, name: String) -> Option<Bank> {
        self.bank_repository.find(name)
    }
}

#[async_trait]
trait BankRegister: Interface {
    async fn register(&mut self, name: String);
}

#[derive(Component)]
#[shaku(interface = BankRegister)]
struct BankRegisterImpl {
    bank_repository: Arc<Mutex<dyn BankRepository>>,
}

#[async_trait]
impl BankRegister for BankRegisterImpl {
    async fn register(&mut self, name: String) {
        let mut lock = self.bank_repository.lock().unwrap();
        lock.insert(Bank { name });
    }
}

trait BankRepository: Interface {
    fn find(&self, name: String) -> Option<Bank>;
    fn insert(&mut self, bank: Bank);
}

// TODO I think the implementation should be replaced with an example by connecting to databases.
#[derive(Component)]
#[shaku(interface = BankRepository)]
struct BankRepositoryOnMemory {
    db: HashMap<String, Bank>,
}

impl BankRepository for BankRepositoryOnMemory {
    fn find(&self, name: String) -> Option<Bank> {
        self.db.get(&name).cloned()
    }

    fn insert(&mut self, bank: Bank) {
        self.db.insert(bank.name.clone(), bank);
    }
}

module! {
    AppModule {
        components = [BankFinderimpl, BankRegisterImpl, BankRepositoryOnMemory],
        providers = []
    }
}

#[tokio::main]
async fn main() {
    // BankRepositoryOnMemoryParameters will be auto-generated by macro.
    let module = AppModule::builder()
        .with_component_parameters::<BankRepositoryOnMemory>(BankRepositoryOnMemoryParameters {
            db: HashMap::new(),
        })
        // with_component_parameters function can be repeatedly used.
        .build();
    // TODO Arc is required to pass actix-web's App. I'll add this later.
    let finder: Arc<&dyn BankFinder> = Arc::new(module.resolve_ref());
    let found = finder.find("bank_a".to_string()).await.unwrap();
    println!("{:?}", found);
}
